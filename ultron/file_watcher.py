import json
import os
# pip3 install requests
import requests
# pip3 install watchdog
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ultron import const
from ultron import core


# The file watcher. This is a wrapper on the watchdog mechanisms.
class EventWrapper(FileSystemEventHandler):
    def __init__(self, callback, path):
        self.callback = callback
        self.observer = Observer()
        self.observer.schedule(self, path=path, recursive=False)
        self.observer.start()

    def on_modified(self, event):
        self.callback(event.src_path, const.MODIFIED)

    def on_created(self, event):
        self.callback(event.src_path, const.CREATED)

    def on_deleted(self, event):
        self.callback(event.src_path, const.DELETED)

    def stop(self):
        self.observer.stop()


# The watched file with its path and the corresponding callback.
class Entity:
    def __init__(self, file_path, func):
        self.file_path = file_path
        self.func = func

    def __eq__(self, other):
        if other.__class__.__name__ == 'str':
            return self.file_path == other
        return self.file_path == other.file_path


# This is used to ignore events generated by python. For more context:
#
# open() call creates two events: CREATION
# close()/destructor calls create one event: MODIFICATION
#
# For reference: http://stackoverflow.com/questions/21587415/
# python-watchdog-modified-and-created-duplicate-events/21589102#21589102
#
# It works as following: it contains a simple list of events that should be
# ignored. Once an event has been ignored, it is removed from the list. An
# event can be present multiple times in the list. When the list is empty,
# the Ignorer instance should be removed as well.
class Ignorer:
    def __init__(self, file_path, events_to_ignore):
        self.file_path = file_path
        self.events_to_ignore = events_to_ignore

    def should_be_ignored(self, event):
        if event in self.events_to_ignore:
            self.events_to_ignore.remove(event)
            return True
        return False

    def should_be_removed(self):
        return len(self.events_to_ignore) == 0

    def __eq__(self, other):
        if other.__class__.__name__ == 'str':
            return self.file_path == other
        return self.file_path == other.file_path


PENDING_CURRENT_ID = 0


class Pending:
    def __init__(self, entity, event, file_path):
        self.entity = entity
        self.event = event
        self.file_path = file_path
        global PENDING_CURRENT_ID
        self.id = PENDING_CURRENT_ID
        PENDING_CURRENT_ID += 1
        if PENDING_CURRENT_ID > 100000:  # This limit is completely arbitrary
            PENDING_CURRENT_ID = 0

    def send_notification(self):
        try:
            requests.put('http://127.0.0.1:{}/{}'
                         .format(core.PORT, const.FILE_WATCHER_PATH),
                         data=json.dumps({'id': self.id}))
        except Exception as e:
            core.LOGS.error('Pending::send_message failed: {}'.format(e), e)


class FileWatcher:
    def __init__(self):
        # Files watched.
        self.entities = {}
        # Watchers. They watch directories, not files so we need to keep tracks
        # of them to avoid to duplicated watched directories.
        self.watchers = {}
        # When you use the open function in Python, it actually fires two
        # events: CREATED and MODIFIED. Since I need to get content of updated
        # files, I don't want duplicated events.
        self.to_ignore = []
        # Contains received eventswhich haven't been called inside main thread
        # yet.
        self.pendings = []

    # If the file is already being watched, the callback will be updated.
    #
    # Arguments:
    # * file_path: The file's path to watch.
    # * func     : The callback to call when a change on the file happens.
    def watch(self, file_path, func):
        if func is None:
            return
        file_path = os.path.abspath(file_path)
        entity = self.entities.get(file_path, None)
        if entity is None:
            self.entities[file_path] = Entity(file_path, func)
            self._add_path(file_path)
        else:
            entity.func = func

    def unwatch(self, file_path):
        file_path = os.path.abspath(file_path)
        entry = self.entities.get(file_path, None)
        if entry is None:
            return
        del self.entities[file_path]
        self._remove_path(file_path)

    def _remove_path(self, file_path):
        dir_path = os.path.dirname(file_path)
        watcher = self.watchers.get(dir_path, None)
        if watcher is None:
            return
        watcher[0] -= 1
        # No more watcher for this entry, we remove it.
        if watcher[0] < 1:
            watcher.stop()
            del self.watchers[dir_path]

    def _add_path(self, path):
        dir_path = os.path.dirname(path)
        if dir_path in self.watchers:
            self.watchers[dir_path][0] += 1
            return
        self.watchers[dir_path] = list((1,
                                        EventWrapper(self._event, dir_path)))

    def add_ignorer(self, ignorer):
        self.to_ignore.append(ignorer)

    def _should_be_ignored(self, file_path, event):
        pos = 0
        for ignorer in self.to_ignore:
            if ignorer == file_path:
                if ignorer.should_be_ignored(event) is True:
                    if ignorer.should_be_removed() is True:
                        self.to_ignore.pop(pos)
                    return True
                break
            pos += 1
        return False

    # When a change happens on a watched resource, this function is called
    # to dispatch the event to the corresponding callback.
    def _event(self, file_path, event):
        for entry in self.entities:
            if entry == file_path:
                if not self._should_be_ignored(file_path, event):
                    pending = Pending(self.entities[entry], event, file_path)
                    self.pendings.append(pending)
                    pending.send_notification()
                break

    def call_pending(self, _id):
        try:
            _id = int(_id)
        except Exception:
            core.LOGS.error('call_pending failed: invalid id')
            return
        for pos, pending in enumerate(self.pendings):
            if pending.id == _id:
                pending.entity.func(pending.event, pending.file_path)
                del self.pendings[pos]
                return
